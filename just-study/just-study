---------------
2014/11/29
---------------
TED: 毅力是成功的钥匙 TED教育
http://open.sina.com.cn/course/id_1012/

TED: 如何在六个月内学会一门外语
http://open.sina.com.cn/course/id_1028/

---------------
2014/12/12
---------------
David Heinemeier Hansson
斯坦福: 忘掉你学过的MBA(1) 远离繁琐的管理理论
http://open.sina.com.cn/course/id_633/#633#open

斯坦福: 忘掉你学过的MBA(2) 计划就等于预测
http://open.sina.com.cn/course/id_633/lesson_5674/

斯坦福: 忘掉你学过的MBA(3) 风险投资就是一个定时炸弹 
http://open.sina.com.cn/course/id_633/lesson_5427/



TED: 我们为什么要睡觉 TED健康 
http://open.sina.com.cn/course/id_966/

TED 套套先生，让泰国更美好
http://v.163.com/movie/2011/7/S/5/M77H4ES89_M77H7QES5.html




---------------
2014/12/21
---------------
TED: 第六感技术的惊异潜力 TED科技 (译)
http://open.sina.com.cn/course/id_619/

TED: 进入计算机的真实世界 TED科技
http://open.sina.com.cn/course/id_918/

TED: 可引发增强现实的图像识别 TED科技 
http://open.sina.com.cn/course/id_1016/
*****Aurasma*****


TED: 神奇的斐波那契数列 TED教育 
http://open.sina.com.cn/course/id_1033/

麻省: K12趣味课程：数学 玩转分形
http://open.sina.com.cn/discipline/id_11/

TED: 科学(1) 我的朋友理查德-费曼
http://open.sina.com.cn/course/view/id_108/



重读大卫与歌利亚的故事
http://open.sina.com.cn/course/id_1036/

TED: 书籍如何成为心灵解药 TED教育
http://open.sina.com.cn/course/id_872/

*****
Coming true is not the only purpose of a dream. Its most important purpose is to get us in touch with where dreams come from, where passion comes from, where happiness comes from. Even a shattered dream can do that for you.
*****




---------------
2014/12/28
---------------
TED: 让科学变得有趣 TED教育 
http://open.sina.com.cn/course/id_849/

TED: 科学(1) 我的朋友理查德-费曼 (译)
http://open.sina.com.cn/course/view/id_108/

TED: 自组织式计算机课程 TED教育 
http://open.sina.com.cn/course/id_757/
★★★★★   
http://www.nand2tetris.org/

有抱负的程序员应看的10个TED演讲
http://www.haokoo.com/digi/40240.html
http://itindex.net/detail/42697-%E7%A8%8B%E5%BA%8F%E5%91%98-ted

10 Must Watch TED Talks For All Aspiring Programmers
https://blog.devbootcamp.com/2013/2013-02-25-10-must-watch-ted-talks-for-all-aspiring-programmers/

User review from amazon.
I have nothing but the most positive things to say about The Elements of Computing Systems. If you ever wanted to know how a computer worked -- I mean REALLY know -- read Charles Petzold's book CODE. If you also wanted to BUILD a computer, read The Elements of Computing Systems. This book takes you from a single basic logic gate to a working computer, then proceeds to design software and even a simple operating system that runs on it. (Caveat: there are 2 things you do not create yourself: the system clock and the base module for flip-flops. There's a good reason why for each. Again, to understand these parts better, I highly recommend Petzold's CODE.) All chapters are independent and can be done in any order, but the order they have it in is best. I think the authors intend for TECS to be a textbook for a class but I'm reading it on my own and it's perfect for self study. Before you read, make sure you consult the book's website's errata because there are a few typos.

I also have nothing but the highest praises for the accompanying software. The authors make freely available a small open source software suite to help develop the computer you're making. Full tutorials are online. The test suites are fully scriptable. The scripts for actually testing your work are included and there's also an appendix in the book explaining the scripting language used. The software is all written in Java and will run on Windows, Linux, or Mac.

Everything is kept as simple as possible without sacrificing any understanding. A perfect learning tool.



---------------
2015/01/02
---------------
From <<The Elements of Computing Systems: Building a Modern Computer from First Principles>>

It turns out that this strategy(modulation) works well thanks to a special gift unique to humans:our ability to create and use abstractions. The notion of abstraction, central to many arts and sciences, is normally taken to be a mental expression that seeks to separate in thought, and capture in some concise manner, the essence of some entity.In computer science, we take the notion of abstraction very concretely, defining it to be a statement of "what the entity does" and ignoring the details of "how it does it".This functional description must capture all that needs to be known in order to use the entity’s services, and nothing more. All the work, cleverness, information, anddrama that went into the entity’s implementation are concealed from the client whois supposed to use it, since they are simply irrelevant. The articulation, use, and im-plementation of such abstractions are the bread and butter of our professional prac-tice: Every hardware and software developer is routinely defining abstractions (also called "interfaces") and then implementing them, or asking other people to imple-ment them. The abstractions are often built layer upon layer, resulting in higher andhigher levels of capabilities.

2015/01/02 jie-zhang:
一段话道破软件行业的根本：我们从事的所有活动，本质上，就是各个层次的抽象和实现过程。宏观来讲，可以是软件工程，微观来讲，可以是计算机语言，计算机软、硬件实现的各个层次。抽象，则成为各个 层次中衡量设计水平的指标。（接口，作为抽象的成果物，应是设计的最后一步，实现的第一步。）一名优秀的设计者，不管其使用的是哪一种语言，也不管其身处在软件工程的哪一个环节，其着眼点应是其基于抽象的设计能力。我们培养和使用的，也就是这种抽象能力。不只计算机业，其他行业，乃至处事方法，大抵如此。

---------------
2015/01/03
---------------
memory-mapped I/O. 
The basic idea is to create a binary emulation of the I/O device, making it "look" to the CPU like a normal memory segment. In particular, each I/O device is allo-cated an exclusive area in memory, becoming its "memory map". In the case of an input device (keyboard, mouse, etc.), the memory map is made to continuously re-flect the physical state of the device; in the case of an output device (screen, speakers,etc.), the memory map is made to continuously drive the physical state of the device.When external events affect some input devices (e.g., pressing a key on the keyboardor moving the mouse), certain values are written in their respective memory maps.Likewise, if we want to manipulate some output devices (e.g., draw something on thescreen or play a tune), we write some values in their respective memory maps. Fromthe hardware point of view, this scheme requires each I/O device to provide an in-terface similar to that of a memory unit. From a software point of view, each I/Odevice is required to define an interaction contract, so that programs can access itcorrectly. As a side comment, given the multitude of available computer platformsand I/O devices, one can appreciate the crucial role that standards play in designingcomputer architectures.

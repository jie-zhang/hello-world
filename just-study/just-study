---------------
2014/11/29
---------------
TED: 毅力是成功的钥匙 TED教育
http://open.sina.com.cn/course/id_1012/

TED: 如何在六个月内学会一门外语
http://open.sina.com.cn/course/id_1028/

---------------
2014/12/12
---------------
David Heinemeier Hansson
斯坦福: 忘掉你学过的MBA(1) 远离繁琐的管理理论
http://open.sina.com.cn/course/id_633/#633#open

斯坦福: 忘掉你学过的MBA(2) 计划就等于预测
http://open.sina.com.cn/course/id_633/lesson_5674/

斯坦福: 忘掉你学过的MBA(3) 风险投资就是一个定时炸弹 
http://open.sina.com.cn/course/id_633/lesson_5427/



TED: 我们为什么要睡觉 TED健康 
http://open.sina.com.cn/course/id_966/

TED 套套先生，让泰国更美好
http://v.163.com/movie/2011/7/S/5/M77H4ES89_M77H7QES5.html




---------------
2014/12/21
---------------
TED: 第六感技术的惊异潜力 TED科技 (译)
http://open.sina.com.cn/course/id_619/

TED: 进入计算机的真实世界 TED科技
http://open.sina.com.cn/course/id_918/

TED: 可引发增强现实的图像识别 TED科技 
http://open.sina.com.cn/course/id_1016/
*****Aurasma*****


TED: 神奇的斐波那契数列 TED教育 
http://open.sina.com.cn/course/id_1033/

麻省: K12趣味课程：数学 玩转分形
http://open.sina.com.cn/discipline/id_11/

TED: 科学(1) 我的朋友理查德-费曼
http://open.sina.com.cn/course/view/id_108/



重读大卫与歌利亚的故事
http://open.sina.com.cn/course/id_1036/

TED: 书籍如何成为心灵解药 TED教育
http://open.sina.com.cn/course/id_872/

*****
Coming true is not the only purpose of a dream. Its most important purpose is to get us in touch with where dreams come from, where passion comes from, where happiness comes from. Even a shattered dream can do that for you.
*****




---------------
2014/12/28
---------------
TED: 让科学变得有趣 TED教育 
http://open.sina.com.cn/course/id_849/

TED: 科学(1) 我的朋友理查德-费曼 (译)
http://open.sina.com.cn/course/view/id_108/

TED: 自组织式计算机课程 TED教育 
http://open.sina.com.cn/course/id_757/
★★★★★   
http://www.nand2tetris.org/

有抱负的程序员应看的10个TED演讲
http://www.haokoo.com/digi/40240.html
http://itindex.net/detail/42697-%E7%A8%8B%E5%BA%8F%E5%91%98-ted

10 Must Watch TED Talks For All Aspiring Programmers
https://blog.devbootcamp.com/2013/2013-02-25-10-must-watch-ted-talks-for-all-aspiring-programmers/

User review from amazon.
I have nothing but the most positive things to say about The Elements of Computing Systems. If you ever wanted to know how a computer worked -- I mean REALLY know -- read Charles Petzold's book CODE. If you also wanted to BUILD a computer, read The Elements of Computing Systems. This book takes you from a single basic logic gate to a working computer, then proceeds to design software and even a simple operating system that runs on it. (Caveat: there are 2 things you do not create yourself: the system clock and the base module for flip-flops. There's a good reason why for each. Again, to understand these parts better, I highly recommend Petzold's CODE.) All chapters are independent and can be done in any order, but the order they have it in is best. I think the authors intend for TECS to be a textbook for a class but I'm reading it on my own and it's perfect for self study. Before you read, make sure you consult the book's website's errata because there are a few typos.

I also have nothing but the highest praises for the accompanying software. The authors make freely available a small open source software suite to help develop the computer you're making. Full tutorials are online. The test suites are fully scriptable. The scripts for actually testing your work are included and there's also an appendix in the book explaining the scripting language used. The software is all written in Java and will run on Windows, Linux, or Mac.

Everything is kept as simple as possible without sacrificing any understanding. A perfect learning tool.



---------------
2015/01/02
---------------
From <<The Elements of Computing Systems: Building a Modern Computer from First Principles>>

It turns out that this strategy(modulation) works well thanks to a special gift unique to humans:our ability to create and use abstractions. The notion of abstraction, central to many arts and sciences, is normally taken to be a mental expression that seeks to separate in thought, and capture in some concise manner, the essence of some entity.In computer science, we take the notion of abstraction very concretely, defining it to be a statement of "what the entity does" and ignoring the details of "how it does it".This functional description must capture all that needs to be known in order to use the entity’s services, and nothing more. All the work, cleverness, information, anddrama that went into the entity’s implementation are concealed from the client whois supposed to use it, since they are simply irrelevant. The articulation, use, and im-plementation of such abstractions are the bread and butter of our professional prac-tice: Every hardware and software developer is routinely defining abstractions (also called "interfaces") and then implementing them, or asking other people to imple-ment them. The abstractions are often built layer upon layer, resulting in higher andhigher levels of capabilities.

2015/01/02 jie-zhang:
一段话道破软件行业的根本：我们从事的所有活动，本质上，就是各个层次的抽象和实现过程。宏观来讲，可以是软件工程，微观来讲，可以是计算机语言，计算机软、硬件实现的各个层次。抽象，则成为各个 层次中衡量设计水平的指标。（接口，作为抽象的成果物，应是设计的最后一步，实现的第一步。）一名优秀的设计者，不管其使用的是哪一种语言，也不管其身处在软件工程的哪一个环节，其着眼点应是其基于抽象的设计能力。我们培养和使用的，也就是这种抽象能力。不只计算机业，其他行业，乃至处事方法，大抵如此。

---------------
2015/01/03
---------------
memory-mapped I/O. 
The basic idea is to create a binary emulation of the I/O device, making it "look" to the CPU like a normal memory segment. In particular, each I/O device is allo-cated an exclusive area in memory, becoming its "memory map". In the case of an input device (keyboard, mouse, etc.), the memory map is made to continuously re-flect the physical state of the device; in the case of an output device (screen, speakers,etc.), the memory map is made to continuously drive the physical state of the device.When external events affect some input devices (e.g., pressing a key on the keyboardor moving the mouse), certain values are written in their respective memory maps.Likewise, if we want to manipulate some output devices (e.g., draw something on thescreen or play a tune), we write some values in their respective memory maps. Fromthe hardware point of view, this scheme requires each I/O device to provide an in-terface similar to that of a memory unit. From a software point of view, each I/Odevice is required to define an interaction contract, so that programs can access itcorrectly. As a side comment, given the multitude of available computer platformsand I/O devices, one can appreciate the crucial role that standards play in designingcomputer architectures.

From pixel's black or white color To real color.
In terms of I/O, the Hack keyboard and screen are rather spartan. General-
purpose computers are typically connected to multiple I/O devices like printers,
disks, network connections, and so on. Also, typical screens are obviously much
more powerful than the Hack screen, featuring more pixels, many brightness levels in each pixel, and colors. Still, the basic principle that each pixel is controlled by a memory-resident binary value is maintained: instead of a single bit controlling the pixel’s black or white color, several bits are devoted to control the level of brightness of each of the three primary colors that, together, produce the pixel’s ultimate color. Likewise, the memory mapping of the Hack screen is simplistic. Instead of mapping pixels directly into bits of memory, most modern computers allow the CPU to send high-level graphic instructions to a graphics card that controls the screen.  This way, the CPU is relieved from the tedium of drawing figures like circles and polygons directly—the graphics card takes care of this task using its own embedded chip-set.


---------------
2015/01/04
---------------
The introduction of symbols into assembly languages suggests that assemblers
must be more sophisticated than dumb text processing programs. Granted, trans-
lating agreed-upon symbols into agreed-upon binary codes is not a complicated task.
At the same time, the mapping of user-defined variable names and symbolic labels
on actual memory addresses is not trivial. In fact, this symbol resolution task is the first nontrivial translation challenge in our ascent up the software hierarchy from the hardware level.
.......
We see that the assembler is essentially a text-processing program, designed to
provide translation services. 

----<<6 Assembler >>


---------------
2015/01/10
---------------

※ *****
当然我在扯淡
http://www.yinwang.org/

麻省理工学院公开课：算法导论
http://v.163.com/special/opencourse/algorithms.html

老赵点滴 - 追求编程之美 推荐内容索引
http://blog.zhaojie.me/2009/12/valuable-posts-index.html#book-recommendation

SICP
http://mitpress.mit.edu/sicp/full-text/book/book.html

Simply Scheme: Introducing Computer Science
http://www.cs.berkeley.edu/~bh/ss-toc2.html

---------------
2015/01/11
---------------
Civilization progresses by extending the number of operations that we can perform without thinking about them.
不用经过特意思考就能执行的操作，其数量的增长推动文明进步。
----Alfred North Whitehead(1861-1947) 数学家
    Introdution to Mathematics 1911.

We shall not cease from exploration, and at the end we will arrive where we started, and know the place for the first time.
永远不应停止探索的脚步，直到最后，再次抵达起点，我们才刚刚开始了解脚下的路。
----T.S.Eliot(1888-1965) 诗人



---------------
2015/01/12
---------------
cheme 语言概要(上)
http://www.ibm.com/developerworks/cn/linux/l-schm/index1.html

Scheme 语言概要（下）
http://www.ibm.com/developerworks/cn/linux/l-schm/index2.html

参考：
Simply Scheme: Introducing Computer Science
http://www.cs.berkeley.edu/~bh/ss-toc2.html

The Little Schemer
Daniel P.Friedman
http://book.douban.com/subject/1632977/

The Scheme Programming Language
R. Kent Dybvig
http://www.scheme.com/tspl4/

http://www.scheme.com/
(chez (chez scheme))



2015/01/18
SICP
第一章确实感受到了设计的优雅。
对过程(方法)和数据一致的处理方式，无疑简化了考虑处理方式，避免了复杂性。天生具有适合递归处理的特性。
内置方法较少，而且几乎所有的内置方法都可以方便的自己定义实现，展现出强大而灵活的扩展能力。规划好抽象的层次，可以实现复杂的功能。
然而函数式语言(FP)本身适合数值计算，文本处理，所以会有大量数学相关的习题，难度也不算小。这本书无疑更适合大学时代的教程。
另外，对递归的诠释部分，对从命令式变成风格(DP)开始学习程序的人有一定帮助。关于算法空间，时间复杂度的估算讲解有理有据。

第二章展示的数据模型，继承了第一章的优雅与强大，但和面向对象的封装机制来比较，封装感略差(依赖于概念上的“抽象屏障”，
而没有实际的物理隔离机制。不能把数据，操作封装在一个类似于class的结构里并能控制其可访问性，比如有理数的构造函数和其他方法部分，
其他方法如果不能限制为对有理数的处理，就有出错的可能)。
封装，抽象的层次更灵活(少可以实现多，少即是多，层层实现，不断抽象)，但对没有掌握这种抽象思想和方法的人来说，无疑有些无所适从。
因而可以理解为什么在概念上更简单，明确，内置方法更多的（，牺牲了一致性的）DP设计思路更容易上手，更容易被市场接受。

值得注意的是Scheme强大的语法表达力。到现在为止，依赖递归解决了所有问题，而没有使用DP中常见的各种循环结构。
而这些结构，自己也可以轻松定义实现，这种感觉在smalltalk中也曾有过。并作为语法糖来使用。




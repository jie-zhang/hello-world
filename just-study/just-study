---------------
2014/11/29
---------------
TED: 毅力是成功的钥匙 TED教育
http://open.sina.com.cn/course/id_1012/

TED: 如何在六个月内学会一门外语
http://open.sina.com.cn/course/id_1028/

---------------
2014/12/12
---------------
David Heinemeier Hansson
斯坦福: 忘掉你学过的MBA(1) 远离繁琐的管理理论
http://open.sina.com.cn/course/id_633/#633#open

斯坦福: 忘掉你学过的MBA(2) 计划就等于预测
http://open.sina.com.cn/course/id_633/lesson_5674/

斯坦福: 忘掉你学过的MBA(3) 风险投资就是一个定时炸弹 
http://open.sina.com.cn/course/id_633/lesson_5427/



TED: 我们为什么要睡觉 TED健康 
http://open.sina.com.cn/course/id_966/

TED 套套先生，让泰国更美好
http://v.163.com/movie/2011/7/S/5/M77H4ES89_M77H7QES5.html




---------------
2014/12/21
---------------
TED: 第六感技术的惊异潜力 TED科技 (译)
http://open.sina.com.cn/course/id_619/

TED: 进入计算机的真实世界 TED科技
http://open.sina.com.cn/course/id_918/

TED: 可引发增强现实的图像识别 TED科技 
http://open.sina.com.cn/course/id_1016/
*****Aurasma*****


TED: 神奇的斐波那契数列 TED教育 
http://open.sina.com.cn/course/id_1033/

麻省: K12趣味课程：数学 玩转分形
http://open.sina.com.cn/discipline/id_11/

TED: 科学(1) 我的朋友理查德-费曼
http://open.sina.com.cn/course/view/id_108/



重读大卫与歌利亚的故事
http://open.sina.com.cn/course/id_1036/

TED: 书籍如何成为心灵解药 TED教育
http://open.sina.com.cn/course/id_872/

*****
Coming true is not the only purpose of a dream. Its most important purpose is to get us in touch with where dreams come from, where passion comes from, where happiness comes from. Even a shattered dream can do that for you.
*****




---------------
2014/12/28
---------------
TED: 让科学变得有趣 TED教育 
http://open.sina.com.cn/course/id_849/

TED: 科学(1) 我的朋友理查德-费曼 (译)
http://open.sina.com.cn/course/view/id_108/

TED: 自组织式计算机课程 TED教育 
http://open.sina.com.cn/course/id_757/
★★★★★   
http://www.nand2tetris.org/

有抱负的程序员应看的10个TED演讲
http://www.haokoo.com/digi/40240.html
http://itindex.net/detail/42697-%E7%A8%8B%E5%BA%8F%E5%91%98-ted

10 Must Watch TED Talks For All Aspiring Programmers
https://blog.devbootcamp.com/2013/2013-02-25-10-must-watch-ted-talks-for-all-aspiring-programmers/

User review from amazon.
I have nothing but the most positive things to say about The Elements of Computing Systems. If you ever wanted to know how a computer worked -- I mean REALLY know -- read Charles Petzold's book CODE. If you also wanted to BUILD a computer, read The Elements of Computing Systems. This book takes you from a single basic logic gate to a working computer, then proceeds to design software and even a simple operating system that runs on it. (Caveat: there are 2 things you do not create yourself: the system clock and the base module for flip-flops. There's a good reason why for each. Again, to understand these parts better, I highly recommend Petzold's CODE.) All chapters are independent and can be done in any order, but the order they have it in is best. I think the authors intend for TECS to be a textbook for a class but I'm reading it on my own and it's perfect for self study. Before you read, make sure you consult the book's website's errata because there are a few typos.

I also have nothing but the highest praises for the accompanying software. The authors make freely available a small open source software suite to help develop the computer you're making. Full tutorials are online. The test suites are fully scriptable. The scripts for actually testing your work are included and there's also an appendix in the book explaining the scripting language used. The software is all written in Java and will run on Windows, Linux, or Mac.

Everything is kept as simple as possible without sacrificing any understanding. A perfect learning tool.



---------------
2015/01/02
---------------
From <<The Elements of Computing Systems: Building a Modern Computer from First Principles>>

It turns out that this strategy(modulation) works well thanks to a special gift unique to humans:our ability to create and use abstractions. The notion of abstraction, central to many arts and sciences, is normally taken to be a mental expression that seeks to separate in thought, and capture in some concise manner, the essence of some entity.In computer science, we take the notion of abstraction very concretely, defining it to be a statement of "what the entity does" and ignoring the details of "how it does it".This functional description must capture all that needs to be known in order to use the entity’s services, and nothing more. All the work, cleverness, information, anddrama that went into the entity’s implementation are concealed from the client whois supposed to use it, since they are simply irrelevant. The articulation, use, and im-plementation of such abstractions are the bread and butter of our professional prac-tice: Every hardware and software developer is routinely defining abstractions (also called "interfaces") and then implementing them, or asking other people to imple-ment them. The abstractions are often built layer upon layer, resulting in higher andhigher levels of capabilities.

2015/01/02 jie-zhang:
一段话道破软件行业的根本：我们从事的所有活动，本质上，就是各个层次的抽象和实现过程。宏观来讲，可以是软件工程，微观来讲，可以是计算机语言，计算机软、硬件实现的各个层次。抽象，则成为各个 层次中衡量设计水平的指标。（接口，作为抽象的成果物，应是设计的最后一步，实现的第一步。）一名优秀的设计者，不管其使用的是哪一种语言，也不管其身处在软件工程的哪一个环节，其着眼点应是其基于抽象的设计能力。我们培养和使用的，也就是这种抽象能力。不只计算机业，其他行业，乃至处事方法，大抵如此。

---------------
2015/01/03
---------------
memory-mapped I/O. 
The basic idea is to create a binary emulation of the I/O device, making it "look" to the CPU like a normal memory segment. In particular, each I/O device is allo-cated an exclusive area in memory, becoming its "memory map". In the case of an input device (keyboard, mouse, etc.), the memory map is made to continuously re-flect the physical state of the device; in the case of an output device (screen, speakers,etc.), the memory map is made to continuously drive the physical state of the device.When external events affect some input devices (e.g., pressing a key on the keyboardor moving the mouse), certain values are written in their respective memory maps.Likewise, if we want to manipulate some output devices (e.g., draw something on thescreen or play a tune), we write some values in their respective memory maps. Fromthe hardware point of view, this scheme requires each I/O device to provide an in-terface similar to that of a memory unit. From a software point of view, each I/Odevice is required to define an interaction contract, so that programs can access itcorrectly. As a side comment, given the multitude of available computer platformsand I/O devices, one can appreciate the crucial role that standards play in designingcomputer architectures.

From pixel's black or white color To real color.
In terms of I/O, the Hack keyboard and screen are rather spartan. General-
purpose computers are typically connected to multiple I/O devices like printers,
disks, network connections, and so on. Also, typical screens are obviously much
more powerful than the Hack screen, featuring more pixels, many brightness levels in each pixel, and colors. Still, the basic principle that each pixel is controlled by a memory-resident binary value is maintained: instead of a single bit controlling the pixel’s black or white color, several bits are devoted to control the level of brightness of each of the three primary colors that, together, produce the pixel’s ultimate color. Likewise, the memory mapping of the Hack screen is simplistic. Instead of mapping pixels directly into bits of memory, most modern computers allow the CPU to send high-level graphic instructions to a graphics card that controls the screen.  This way, the CPU is relieved from the tedium of drawing figures like circles and polygons directly—the graphics card takes care of this task using its own embedded chip-set.


---------------
2015/01/04
---------------
The introduction of symbols into assembly languages suggests that assemblers
must be more sophisticated than dumb text processing programs. Granted, trans-
lating agreed-upon symbols into agreed-upon binary codes is not a complicated task.
At the same time, the mapping of user-defined variable names and symbolic labels
on actual memory addresses is not trivial. In fact, this symbol resolution task is the first nontrivial translation challenge in our ascent up the software hierarchy from the hardware level.
.......
We see that the assembler is essentially a text-processing program, designed to
provide translation services. 

----<<6 Assembler >>


---------------
2015/01/10
---------------

※ *****
当然我在扯淡
http://www.yinwang.org/

麻省理工学院公开课：算法导论
http://v.163.com/special/opencourse/algorithms.html

老赵点滴 - 追求编程之美 推荐内容索引
http://blog.zhaojie.me/2009/12/valuable-posts-index.html#book-recommendation

SICP
http://mitpress.mit.edu/sicp/full-text/book/book.html

Simply Scheme: Introducing Computer Science
http://www.cs.berkeley.edu/~bh/ss-toc2.html

---------------
2015/01/11
---------------
Civilization progresses by extending the number of operations that we can perform without thinking about them.
不用经过特意思考就能执行的操作，其数量的增长推动文明进步。
----Alfred North Whitehead(1861-1947) 数学家
    Introdution to Mathematics 1911.

We shall not cease from exploration, and at the end we will arrive where we started, and know the place for the first time.
永远不应停止探索的脚步，直到最后，再次抵达起点，我们才刚刚开始了解脚下的路。
----T.S.Eliot(1888-1965) 诗人

